use ftp::FtpStream;
//use ftp::openssl::ssl::{ SslContext, SslMethod };
use crate::sql::models::*;
use std::env;

pub fn get_filelist(ip: String, port: String) -> Vec<File> {

	let mut files = Vec::<File>::new();
	let url = ip.to_owned() + ":" + &port;
	println!("get Stream");
	let mut ftp_stream = get_stream(url);
	println!("get list");
	println!("quit Stream");
	let files = get_folder_list(ftp_stream,files,"/");
	let _ = ftp_stream.quit();
	return files;
}
fn get_folder_list(stream:FtpStream, mut files:Vec<File>, path:String) -> Vec<File> {
	let filelist_str = stream.nlst(Some(&path)).unwrap();
	for line in filelist_str {
		let abs_path = "/".to_owned() + &line;
		let size = stream.size(&abs_path);
		if size.is_ok() {
			let new_file = File { path: path, filename: line, id: 0, synced: false, deleted:false };
			files.push(new_file);
		} else {
			files.extend(get_folder_list(stream,files,abs_path));
		}
	}
	return files;
}

fn get_stream (url:String) -> FtpStream {
	let mut ftp_stream = FtpStream::connect(url).unwrap();
//	let ctx = SslContext::builder(SslMethod::tls()).unwrap().build();
	// Switch to the secure mode
	let user = env::var("FTP_USER").expect("ftp-username not set");
	let pass = env::var("FTP_PASS").expect("ftp-password not set");
//	println!("get Stream...");
//	let mut ftp_stream = ftp_stream.into_secure(ctx).unwrap();
	ftp_stream.login(&user, &pass).unwrap();
	return ftp_stream;
}
